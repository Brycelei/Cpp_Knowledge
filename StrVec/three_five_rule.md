# 三个基本操作可以控制类的拷贝操作
- * 拷贝构造函数
- * 拷贝赋值运算符
- * 析构函数 
  * 新标准下：一个类还可以定义一个移动构造函数和一个移动赋值运算符
  这些操作通常该被看为一个整体，通常，只需要其中一个操作，而不需要定义所有操作的情况是很少见的。

# 如果一个类需要自定义析构函数，几乎可以肯定它也需要自定义拷贝赋值运算符和拷贝构造函数
- 一般需要定义拷贝赋值运算符，那么也需要定义拷贝构造函数
- 反之亦然
- 但是，无论定义拷贝赋值运算符或者拷贝构造函数，都不一定需要析构函数。
  
  # 补充
- 某些类必须定义拷贝构造函数、拷贝赋值运算符和析构函数才能正常工作，这些类通常需要拥有一个资源
  而拷贝成员必须拷贝此资源，一般来说，拷贝一个资源会导致一些额外的开销，在这种拷贝并非必要的情
  况下，定义了移动构造函数和移动赋值运算符的类就可以避免此问题。

# 移动构造函数和移动赋值运算符
- 类似拷贝构造函数，移动构造函数的第一个参数是该类类型的一个引用，不同于拷贝构造函数，这个引用参数
  在移动构造函数中是一个右值引用。与拷贝构造函数一样，任何额外的参数都必须要有默认实惨。
  完成了资源移动，移动构造函数还必须确保移后源对象处于一个状态`销毁它是无害的`,一旦完成移动，源对象
  不再指向被移动的资源，`这些资源的所有权已经归属于新创建的对象`。
```c++
// 移动构造函数
 StrVec::StrVec(StrVec &&s) noexcept
        : elements(s.elements), first_free(s.first_free), cap(s.cap)
    {
        s.elements = s.first_free = s.cap = nullptr;
    }

//移动赋值运算符
StrVec &StrVec::operator=(StrVec &&rhs) noexcept
{
    if (this != &rhs)
    {
        free();
        elements = rhs.elements;
        first_free = rhs.first_free;
        cap = rhs.cap;
        rhs.elements = rhs.first_free = rhs.cap = nullptr;
    }
    return *this;
}
```